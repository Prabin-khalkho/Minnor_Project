
# app.py (save this in excel_uploader/app.py)

from flask import Flask, render_template, request, flash, redirect, url_for, session
import pandas as pd
import mysql.connector
from mysql.connector import Error
import numpy as np
from werkzeug.utils import secure_filename
import os
from datetime import datetime
import tempfile
import re

app = Flask(__name__)
app.secret_key = 'your_secret_key_here'  # Change this to a secure secret key

# Configure upload folder
UPLOAD_FOLDER = tempfile.gettempdir()
ALLOWED_EXTENSIONS = {'csv', 'xlsx', 'xls'}

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def clean_table_name(filename):
    """
    Clean the filename to create a valid MySQL table name
    Remove file extension and clean special characters
    """
    # Remove file extension
    name = filename.rsplit('.', 1)[0]
    
    # Replace spaces and special characters with underscores
    name = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    
    # Remove multiple consecutive underscores
    name = re.sub(r'_+', '_', name)
    
    # Remove leading/trailing underscores
    name = name.strip('_')
    
    # Ensure it starts with a letter or underscore (MySQL requirement)
    if name and not name[0].isalpha() and name[0] != '_':
        name = 'table_' + name
    
    # Ensure it's not empty
    if not name:
        name = 'uploaded_table'
    
    # Convert to lowercase for consistency
    name = name.lower()
    
    return name

class DatabaseManager:
    @staticmethod
    def test_connection(host, user, password, database):
        try:
            conn = mysql.connector.connect(
                host=host,
                user=user,
                password=password,
                database=database
            )
            if conn.is_connected():
                conn.close()
                return True
        except Error as e:
            print(f"Error: {e}")
            return False
        return False

    @staticmethod
    def get_mysql_type(dtype):
        if pd.api.types.is_integer_dtype(dtype):
            return 'VARCHAR(255)'
        elif pd.api.types.is_float_dtype(dtype):
            return 'FLOAT'
        elif pd.api.types.is_datetime64_any_dtype(dtype):
            return 'DATETIME'
        elif pd.api.types.is_bool_dtype(dtype):
            return 'BOOLEAN'
        else:
            return 'VARCHAR(255)'

    @staticmethod
    def create_table_and_upload_data(db_config, df, table_name):
        try:
            conn = mysql.connector.connect(**db_config)
            cursor = conn.cursor()

            # Debug: Print table creation info
            print(f"Creating table: {table_name}")
            print(f"DataFrame shape: {df.shape}")
            print(f"DataFrame columns: {list(df.columns)}")

            # Clean column names
            original_columns = df.columns.tolist()
            df.columns = [''.join(e for e in col if e.isalnum() or e == '_') for col in df.columns]
            
            # Create table
            columns = []
            for column, dtype in df.dtypes.items():
                mysql_type = DatabaseManager.get_mysql_type(dtype)
                clean_column = ''.join(e for e in column if e.isalnum() or e == '_')
                if not clean_column:  # If column name becomes empty after cleaning
                    clean_column = f"column_{len(columns) + 1}"
                columns.append(f"`{clean_column}` {mysql_type}")

            # Drop table if exists (to handle updates)
            drop_table_query = f"DROP TABLE IF EXISTS `{table_name}`"
            cursor.execute(drop_table_query)
            print(f"Dropped existing table: {table_name}")

            create_table_query = f"""
            CREATE TABLE `{table_name}` (
                id INT AUTO_INCREMENT PRIMARY KEY,
                {', '.join(columns)},
                upload_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
            """
            
            print(f"Create table query: {create_table_query}")
            cursor.execute(create_table_query)
            print(f"Table created successfully: {table_name}")

            # Insert data
            columns_for_insert = ', '.join([f"`{col}`" for col in df.columns])
            placeholders = ', '.join(['%s'] * len(df.columns))
            insert_query = f"INSERT INTO `{table_name}` ({columns_for_insert}) VALUES ({placeholders})"
            
            print(f"Insert query: {insert_query}")
            
            # Convert DataFrame to list of tuples for insertion
            data = []
            for _, row in df.iterrows():
                row_data = []
                for value in row:
                    if pd.isna(value):
                        row_data.append(None)
                    else:
                        row_data.append(str(value))
                data.append(tuple(row_data))
            
            print(f"Inserting {len(data)} rows")
            cursor.executemany(insert_query, data)
            conn.commit()

            # Verify table creation
            cursor.execute(f"SHOW TABLES LIKE '{table_name}'")
            table_exists = cursor.fetchone()
            
            if table_exists:
                cursor.execute(f"SELECT COUNT(*) FROM `{table_name}`")
                row_count = cursor.fetchone()[0]
                print(f"Table {table_name} created with {row_count} rows")
                return True, row_count
            else:
                return False, "Table was not created successfully"

        except Error as e:
            print(f"Database error: {e}")
            return False, str(e)
        except Exception as e:
            print(f"General error: {e}")
            return False, str(e)
        finally:
            if 'conn' in locals() and conn.is_connected():
                cursor.close()
                conn.close()

    @staticmethod
    def list_tables(db_config):
        """List all tables in the database"""
        try:
            conn = mysql.connector.connect(**db_config)
            cursor = conn.cursor()
            cursor.execute("SHOW TABLES")
            tables = [table[0] for table in cursor.fetchall()]
            return tables
        except Error as e:
            print(f"Error listing tables: {e}")
            return []
        finally:
            if 'conn' in locals() and conn.is_connected():
                cursor.close()
                conn.close()

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/connect', methods=['POST'])
def connect():
    host = request.form['host']
    user = request.form['user']
    password = request.form['password']
    database = request.form['database']
    
    if DatabaseManager.test_connection(host, user, password, database):
        session['db_config'] = {
            'host': host,
            'user': user,
            'password': password,
            'database': database
        }
        flash('Database connection successful!', 'success')
        return redirect(url_for('upload'))
    else:
        flash('Failed to connect to database. Please check your credentials.', 'error')
        return redirect(url_for('index'))

@app.route('/upload')
def upload():
    if 'db_config' not in session:
        flash('Please connect to database first', 'error')
        return redirect(url_for('index'))
    
    # List existing tables for debugging
    tables = DatabaseManager.list_tables(session['db_config'])
    print(f"Existing tables in database: {tables}")
    
    return render_template('upload.html')

@app.route('/process', methods=['POST'])
def process():
    if 'file' not in request.files:
        flash('No files selected', 'error')
        return redirect(url_for('upload'))
    
    files = request.files.getlist('file')
    
    results = []
    total_records = 0
    successful_uploads = 0
    failed_uploads = 0

    for file in files:
        if file.filename == '':
            continue
            
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            file.save(filepath)

            try:
                print(f"Processing file: {filename}")
                
                # Read the file
                if filename.endswith('.csv'):
                    df = pd.read_csv(filepath)
                else:
                    df = pd.read_excel(filepath)

                print(f"File read successfully. Shape: {df.shape}")
                print(f"Columns: {list(df.columns)}")

                # Generate clean table name from filename
                clean_table_name_result = clean_table_name(filename)
                print(f"Table name will be: {clean_table_name_result}")

                # Process the file
                success, result = DatabaseManager.create_table_and_upload_data(
                    session['db_config'], df, clean_table_name_result
                )

                os.remove(filepath)  # Clean up the temporary file

                if success:
                    results.append(f"✓ {filename}: {result} records uploaded to table '{clean_table_name_result}'")
                    total_records += result
                    successful_uploads += 1
                    print(f"Successfully uploaded {filename} to table {clean_table_name_result}")
                else:
                    results.append(f"✗ {filename}: Error - {result}")
                    failed_uploads += 1
                    print(f"Failed to upload {filename}: {result}")

            except Exception as e:
                error_msg = f"Error processing file {filename}: {str(e)}"
                print(error_msg)
                results.append(f"✗ {filename}: {error_msg}")
                failed_uploads += 1
                if os.path.exists(filepath):
                    os.remove(filepath)
        else:
            results.append(f"✗ {file.filename}: Invalid file type")
            failed_uploads += 1

    # Create summary message
    if successful_uploads > 0:
        summary = f"Upload completed: {successful_uploads} successful, {failed_uploads} failed. Total records: {total_records}"
        flash(summary, 'success' if failed_uploads == 0 else 'warning')
    else:
        flash("All uploads failed", 'error')
    
    # Flash individual file results
    for result in results:
        if result.startswith('✓'):
            flash(result, 'success')
        else:
            flash(result, 'error')
    
    # List tables after upload for verification
    tables = DatabaseManager.list_tables(session['db_config'])
    print(f"Tables after upload: {tables}")
            
    return redirect(url_for('upload'))

if __name__ == '__main__':
    app.run(debug=True)
